#! /usr/bin/env node
// import data from "../data/tsData.json";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
const __filename = fileURLToPath(import.meta.url);
import { createSpinner } from "nanospinner";
import inquirer from "inquirer";

askLanguage();
const sleep = (ms = 2000) => new Promise((r) => setTimeout(r, ms));
async function askLanguage() {
  const name = await inquirer.prompt({
    name: "name",
    type: "input",
    message: "Specify the name of your bot.",
    default: () => "discord-bot",
  });
  const q = await inquirer.prompt({
    name: "Language",
    type: "list",
    message: "Select a language for the bot.",
    choices: ["TypeScript", "JavaScript"],
  });
  const lang = q.Language;
  handleAnswer(lang, name.name);
}

/**
 * @param {String} language
 * @param {String} name
 */
async function handleAnswer(language = String, name = String) {
  if (language === "TypeScript") {
    const spinner = createSpinner("Loading").start();
    generateFiles(name);
    await sleep(3000);
    spinner.success({ text: "Setup Complete." });
  }
}

async function generateFiles(name) {
  // tsConfig
  fs.writeFile(
    "tsconfig.json",
    `{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "node",
    "declaration": true,
    "outDir": "./src",
    "declarationDir": "./src",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "alwaysStrict": true,
    "skipLibCheck": true
  },
  "include": ["./typescript"]
}`,
    (error) => {
      return;
    }
  );

  fs.writeFile(
    "package.json",
    `{
  "name": "${name}",
  "version": "1.0.0",
  "description": "Generated by the bot creator cli",
  "main": "src/client.js",
  "type": "module",
  "scripts": {
    "test": "echo Error: no test specified && exit 1",
    "watch": "tsc --watch",
    "dev": "nodemon src/client.js"
  },
  "keywords": [
    "discord_bot",
    "TypeScript"
  ],
  "author": "Ritesh",
  "license": "MIT",
  "dependencies": {
    "@commitlint/config-conventional": "^17.4.2",
    "@discordjs/voice": "^0.14.0",
    "@types/cors": "^2.8.13",
    "@types/express": "^4.17.15",
    "@types/ms": "^0.7.31",
    "@types/pretty-ms": "^5.0.1",
    "axios": "^1.2.3",
    "cors": "^2.8.5",
    "pretty-ms": "^8.0.0",
    "discord.js": "^14.7.1",
    "express": "^4.18.2",
    "moment": "^2.29.4",
    "mongoose": "^6.8.4",
    "ms": "^2.1.3",
    "node-fetch": "^3.3.0",
    "nodemon": "^2.0.20"
  }
}
`,
    () => {
      return;
    }
  );

  fs.mkdir("typescript", (e) => {
    return;
  });
  fs.mkdir("typescript/structures", (e) => {
    return;
  });
  fs.mkdir("typescript/structures/client", (e) => {
    return;
  });

  fs.mkdir("typescript/structures/typings", (e) => {
    return;
  });

  fs.mkdir("typescript/structures/client/exports", () => {
    return;
  });
  fs.writeFile(
    "typescript/structures/client/exports/index.ts",
    `export { default as ClientStructure } from "../Keys/index.js";`,
    (e) => {
      return;
    }
  );
  fs.mkdir("typescript/structures/typings/exports", (e) => {
    return;
  });

  fs.mkdir("typescript/structures/typings/interfaces", (e) => {
    return;
  });

  fs.writeFile(
    "typescript/structures/client/exports/index.ts",
    `export { default as ClientStructure } from "../Keys/index.js";`,
    (e) => {
      return;
    }
  );

  fs.mkdir("typescript/structures/client/Keys", (e) => {
    return;
  });
  fs.writeFile(
    "typescript/structures/client/Keys/index.ts",
    `// Modules
import { ClientEvents } from "discord.js";
import { readdirSync } from "fs";
import path from "path";
import { fileURLToPath } from "url";
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
import {
  slashCommandsCollection,
  eventsCollection,
} from "../../../collections/exports/index.js";
import { config } from "../../../configuration/config.conf.js";
import { Event, SlashCommandsCollection } from "../../typings/exports/index.js";
import { client } from "../../../exports/index.js";
export default class Structure {
  importFile = async (filePath: string) => {
    return (await import(filePath))?.default;
  };

  start = async () => {
    const slashCommands: SlashCommandsCollection[] = [];
    const dir = process.cwd() + "/src/client/commands";
    readdirSync(dir).forEach(
      async (commandsDirectory: string, index: number) => {
        const commands = readdirSync(${"`${dir}/${commandsDirectory}`"}).filter(
          (file) => file.endsWith(".js")
        );
        for (const command of commands) {
          const executorCommand = await import(
            
            ${"`../../../client/commands/${commandsDirectory}/${command}`"}
            );
          const defaultCommand =
            executorCommand.default as SlashCommandsCollection;
          defaultCommand.name !== ""
            ? slashCommands.push({
                ...defaultCommand,
              }) &&
              slashCommandsCollection.set(defaultCommand.name, defaultCommand)
            : console.log("The command is not ready yet");
        }
      }
    );
    client.on(
      "ready",
      async () =>
        (await client.guilds.cache
          .get(config.guildId || (config.guildId as string))
          ?.commands.set([...slashCommands])) &&
        console.log("The client is now alive")
    );
    const eventDir = process.cwd() + "/src/client/events/";
    const eventFiles = readdirSync(eventDir).filter((file) =>
      file.endsWith(".js")
    );
    for (const file of eventFiles) {
      console.log(file);
      const events: Event<keyof ClientEvents> = await this.importFile(
        ${"`../../../client/events/${file}`"}
      );
      eventsCollection.set(events.event, file);
      console.log(events);
      client.on(events.event, events.execute);
    }
    // });
  };
}


      
        `,
    (e) => {
      return;
    }
  );
  fs.mkdir("typescript/collections", (e) => {});
  fs.mkdir("typescript/collections/commands", (e) => {});
  fs.mkdir("typescript/collections/events", (e) => {});
  fs.mkdir("typescript/collections/exports", (e) => {});

  fs.writeFile(
    "typescript/collections/commands/slashCommandsCollection.ts",
    `import { Collection } from "discord.js";
const slashCommandsCollection = new Collection();
export default slashCommandsCollection;`,
    (e) => {
      return;
    }
  );

  fs.writeFile(
    "typescript/collections/events/eventsCollection.ts",
    `import { Collection } from "discord.js";
const eventsCollection = new Collection();
export default eventsCollection;`,
    (e) => {
      return;
    }
  );
  fs.writeFile(
    "typescript/collections/exports/index.ts",
    `export { default as slashCommandsCollection } from "../commands/slashCommandsCollection.js";
      export { default as eventsCollection } from "../events/eventsCollection.js";`,
    () => {
      return;
    }
  );
  fs.mkdir("typescript/configuration", (e) => {
    return;
  });
  fs.writeFile(
    "typescript/configuration/config.conf.ts",
    `interface ConfigOptions {
  token: string;
  guildId: string;
  mongooseConnectionURI: string;
}
export const config: ConfigOptions = {
  token:
    "Bot Token",
  guildId: "Guild Id",
  mongooseConnectionURI:
    "Mongoose URI",
};`,
    (e) => {
      return;
    }
  );

  fs.mkdir("typescript/data", () => {
    return;
  });

  fs.mkdir("typescript/data/emojis", () => {
    return;
  });
  fs.writeFile(
    "typescript/data/emojis/emojis.ts",
    `export default {
  playing: "<:PlayEmoji:1065643719350550578>",
  paused: "<:PausedEmoji:1065643921646035026>",
  stop: "<:StopEmoji:1065645176757956699>",
  information: "",
  success: "<:SuccessEmoji:1065644575907135550>",
  error: "<:ErrorEmoji:1065644392486010890>",
  mainColor: "#0781e6",
  errorColor: "#bd0921",
  successColor: "#06bd5b",
};
`,
    () => {
      return;
    }
  );

  fs.mkdir("typescript/client", () => {
    return;
  });
  fs.mkdir("typescript/client/commands", () => {
    return;
  });

  fs.mkdir("typescript/client/events", () => {
    return;
  });

  fs.mkdir("typescript/client/functions", () => {
    return;
  });

  fs.mkdir("typescript/client/functions/exports", () => {
    return;
  });

  fs.mkdir("typescript/client/functions/triggers", () => {
    return;
  });

  fs.writeFile(
    "typescript/client.ts",
    `// Modules
import { Client, GatewayIntentBits, Partials } from "discord.js";
import { config as Config } from "./configuration/config.conf.js";
import { ClientStructure } from "./structures/client/exports/index.js";
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildVoiceStates,
    GatewayIntentBits.GuildMembers,
  ],
  partials: [
    Partials.GuildMember,
    Partials.Channel,
    Partials.User,
    Partials.ThreadMember,
  ],
});
client.login(${"`${Config.token}`"} || (Config.token as string));
export default client;
new ClientStructure().start();`,
    (e) => {
      return;
    }
  );
  fs.writeFile(
    "typescript/client/functions/triggers/handler.ts",

    `import {
  ChatInputApplicationCommandData,
  ChatInputCommandInteraction,
  Collection,
  CommandInteractionOptionResolver,
  GuildMember,
} from "discord.js";
import ms from "ms";
import prettyMs from "pretty-ms";
import client from "../../../client.js";
import botConfig from "../../../data/emojis/emojis.js";
import { SlashCommandsCollection } from "../../../structures/typings/exports/index.js";
const Timeout = new Collection();

export default async function handleEverything(
  command: SlashCommandsCollection & ChatInputApplicationCommandData,
  interaction: ChatInputCommandInteraction & { member?: GuildMember }
) {
  const { timeout } = command;
  if (timeout === "" || !timeout) return;
  const timedOut = ms(timeout || ${"`${timeout}`"});
  const coolDown = prettyMs(timedOut, {
    verbose: true,
  });

  if (Timeout.has(${"`${command.name}${interaction?.member.id}`"})) {
    return interaction.reply({
      content: ${"`${botConfig.error} You have a timeout of ${coolDown}`,"}
      ephemeral: true,
    });
  }

  if (command.voiceChannelConnected) {
    if (!interaction.member.voice.channel)
      return interaction.reply({
        content: ${"`${botConfig?.error} You need to be in a voice channel in order to listen something.`,"}
        ephemeral: true,
      });

    if (
      interaction?.guild?.members?.me?.voice.channel &&
      interaction.member.voice.channelId !==
        interaction.guild.members.me.voice.channelId
    )
      return interaction.reply({
        ephemeral: true,
        content: ${"`${botConfig.error} Sorry, **${interaction.member.user?.username}** but i am already connected to **${interaction.guild.members.me.voice.channel}**`"},
      });
  }

  await command.execute({
    args: interaction.options as CommandInteractionOptionResolver,
    client,
    interaction: interaction as ChatInputCommandInteraction & {
      member?: GuildMember;
    },
  });
  Timeout.set(${"`${command.name}${interaction.member.id}`"}, Date.now() + timeout);
  setTimeout(() => {
    return Timeout.delete(${"`${command.name}${interaction.member.id}`"});
  }, Number(timeout));
}`,
    () => {
      return;
    }
  );
  fs.mkdir("typescript/@types/modules", () => {
    return;
  });
  fs.writeFile("typescript/@types/modules/index.d.ts", ``, () => {
    return;
  });

  fs.mkdir("typescript/structures/typings/interfaces/CommandInterface", (e) => {
    return;
  });
  fs.mkdir(
    "typescript/structures/typings/interfaces/CollectionsInterface",
    (e) => {
      return;
    }
  );
  fs.writeFile(
    "typescript/structures/typings/interfaces/CollectionsInterface/SlashCommands.ts",
    `import {
  Client,
  ChatInputCommandInteraction,
  CommandInteractionOptionResolver,
  ApplicationCommandOption,
  GuildMember,
} from "discord.js";
interface ExecuteOptions {
  client: Client;
  interaction: ChatInputCommandInteraction & { member?: GuildMember };
  args?: CommandInteractionOptionResolver;
}

type ExecuteFunction = (options: ExecuteOptions) => any;

declare interface SlashCommandsCollection {
  name: string;
  description: string;
  options?: ApplicationCommandOption[];
  voiceChannelConnected?: boolean;
  execute: ExecuteFunction;
  timeout?: string;
}

export default SlashCommandsCollection;`,
    () => {
      return;
    }
  );

  fs.writeFile(
    "typescript/structures/typings/interfaces/CommandInterface/Command.ts",

    `import {
  ChatInputApplicationCommandData,
  ChatInputCommandInteraction,
  CommandInteractionOptionResolver,
  GuildMember,
  Client,
  PermissionResolvable,
} from "discord.js";

interface ExecuteOptions {
  client: Client;
  interaction: ChatInputCommandInteraction & { member?: GuildMember };
  args?: string;
}

type ExecuteFunction = (options: ExecuteOptions) => any;

type CommandType = {
  timeout: string;
  voiceChannelConnected?: boolean;
  userPermissions?: PermissionResolvable[];
  execute: ExecuteFunction;
} & ChatInputApplicationCommandData;

export default class Command {
  constructor(commandOptions: CommandType) {
    Object.assign(this, commandOptions);
  }
}`,
    (e) => {
      return;
    }
  );

  fs.writeFile(
    "typescript/structures/typings/interfaces/CommandInterface/EventInterface.ts",

    `import { ClientEvents } from "discord.js";
export default class Event<Key extends keyof ClientEvents> {
  constructor(
    public event: Key,
    public execute: (...args: ClientEvents[Key]) => any
  ) {}
}`,
    (e) => {
      return;
    }
  );

  fs.writeFile(
    "typescript/structures/typings/interfaces/CollectionInterface/SlashCommands.ts",
    `import {
  Client,
  ChatInputCommandInteraction,
  CommandInteractionOptionResolver,
  ApplicationCommandOption,
  GuildMember,
} from "discord.js";
interface ExecuteOptions {
  client: Client;
  interaction: ChatInputCommandInteraction & { member?: GuildMember };
  args?: CommandInteractionOptionResolver;
}

type ExecuteFunction = (options: ExecuteOptions) => any;

declare interface SlashCommandsCollection {
  name: string;
  description: string;
  options?: ApplicationCommandOption[];
  voiceChannelConnected?: boolean;
  execute: ExecuteFunction;
  timeout?: string;
}

export default SlashCommandsCollection;`,
    () => {
      return;
    }
  );

  fs.writeFile(
    "typescript/structures/typings/exports/index.ts",
    `export { default as SlashCommandsCollection } from "../interfaces/CollectionsInterface/SlashCommands.js";
export { default as Command } from "../interfaces/CommandInterface/Command.js";
export { default as Event } from "../interfaces/CommandInterface/EventInterface.js";
`,
    () => {
      return;
    }
  );

  fs.mkdir("typescript/exports", (e) => {
    return;
  });
  fs.writeFile(
    "typescript/exports/index.ts",
    `export { default as client } from "../client.js";
`,
    () => {
      return;
    }
  );
  fs.writeFile(
    "typescript/client/events/interactionCreate.ts",
    `// Modules
import {
  ApplicationCommandOptionWithChoicesAndAutocompleteMixin,
  ChatInputCommandInteraction,
  GuildMember,
} from "discord.js";
import {
  Event,
} from "../../structures/typings/exports/index.js";
import { slashCommandsCollection } from "../../collections/exports/index.js";
import { SlashCommandsCollection } from "../../structures/typings/exports/index.js";
import { Handler } from "../functions/exports/index.js";

export default new Event("interactionCreate", async (interaction) => {
  if (interaction.isChatInputCommand()) {
    const command = slashCommandsCollection.get(
      interaction.commandName
    ) as SlashCommandsCollection;
    if (command === null || undefined || !command)
      return interaction.reply({
        content: "The command is non existing",
        ephemeral: true,
      });
await Handler(
  command,
  interaction as ChatInputCommandInteraction & {
    member?: GuildMember;
  }
);
  }
})`,
    () => {
      return;
    }
  );

  fs.writeFile;
  "typescript/client/events/ready.ts",
    `import { Event } from "../../structures/typings/exports/index.js";
import mongoose from "mongoose";
import { config } from "../../configuration/config.conf.js";
import { ActivityType } from "discord.js";
mongoose.set("strictQuery", true);

export default new Event("ready", async (client) => {
	client.user.setStatus("idle");
	client.user.setActivity({
		name: "No risk, no story ✨",
		type: ActivityType.Playing,
	});
	await mongoose
		.connect(config.mongooseConnectionURI)
		.then(() => console.log("✅ | The mongoDB has been connected"));
	console.log("The bot is now up");
});`,
    (e) => {
      return;
    };

  fs.mkdir("src", () => {
    return;
  });

  fs.writeFile(
    "typescript/client/functions/exports/index.ts",

    `export { default as Handler } from "../triggers/handler.js";`,
    () => {
      return;
    }
  );
}
